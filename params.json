{"name":"git-fc","tagline":"Fork of Git, same baseline, more features","body":"# git-fc\r\n\r\ngit-fc is a friendly fork of Git, which means it's a fork that won't deviate\r\nfrom the mainline; it is more like a branch in Git terms. This branch will move\r\nforward close to Git's mainline, and it could be merged at any point in time,\r\nif the maintainer wished to do so.\r\n\r\ngit-fc doesn't include experimental code, or half-assed features, so you can\r\nexpect the same level of stability as Git's mainline. Also, it doesn't remove\r\nany feature, or do any backwards incompatible changes, so you can replace git\r\nwith git-fc and you wouldn't notice the difference. The difference comes in the\r\nextra features, that is all.\r\n\r\n## Maintenance\r\n\r\nEach release of Git is merged directly into git-fc, so if there's a new feature\r\nin Git, git-fc will get it as well.\r\n\r\nEvery extra feature is maintained individually in a separate branch, so if you\r\nare interested in a specific feature and don't trust the rest of git-fc, you\r\ncan use that branch instead. For example the publish tracking branch feature is\r\nmaintained in the 'fc/publish' branch which sits on top of git.git's v1.9.2.\r\nYou can grab the specific branch and do whatever you want with it.\r\n\r\n## Extra features\r\n\r\n### Streamlined remote helpers\r\n\r\n`git-remote-hg` and `git-remote-bzr` are remote helpers that allow two-way\r\ncommunication between Git and Mercurial/Bazaar. They have been proven to be\r\nvery reliable and solid, and used by many people. In order to use them in Git\r\nmainline you might need a bit of tinkering.\r\n\r\nWith git-fc they are installed by default, and in the right way. Plus there are\r\nfixes in the remote helper infraestructure so they always work better than in\r\nGit mainline.\r\n\r\n### New 'git update' tool\r\n\r\nEverybody has agreed the `git pull` command is broken for most use-cases, which\r\nis why most seasoned Git users avoid it, and it is recommended for new users to\r\navoid it.\r\n\r\nA new tool is necessary for the most common use case, which is fetch all the\r\nupdates and update the current branch if possible.\r\n\r\nThe new `git update` will fast-forward to the latest commit in the remote\r\nbranch if there's no divergence (you haven't made extra commits). But if you\r\nhave made extra commits you will be told to either merge or rebase, or run `git\r\nupdate --merge` or `git update --rebase`.\r\n\r\nThis ensures that new users won't be making merges by mistake.\r\n\r\nAdditionally, when doing a merge the order of the parents will be reversed, so\r\nit would appear as if you are merging your local branch to the remote one, and\r\nnot the other way around like `git pull` does. Everybody has agreed this is a\r\nproblem with `git pull`.\r\n\r\n### Publish tracking branch\r\n\r\nGit mainline doesn't have the greatest support for triangular workflows, a good\r\nsolution for that is to introduce a second \"upstream\" tracking branch which is\r\nfor the reverse; the branch you normally push to.\r\n\r\nSay you clone a repository (libgit2) in GitHub, then create a branch\r\n(feature-a) and push it to your personal repository, you would want to track\r\ntwo branches (origin/master), and (mine/feature-a), but Git mainline only\r\nprovides support for a single upstream tracking branch.\r\n\r\nIf you setup your upstream tracking branch to 'origin/master', then you can\r\njust do `git rebase` without arguments and git will pick the right branch\r\n(origin/master) to rebase to. However, `git push` by default will also try to\r\npush to 'origin/master', which is not what you want. Plus `git branch -v` will\r\nshow how ahead/behind your branch is compared to origin/master, not\r\nmine/feature-a.\r\n\r\nIf you set up your upstream to 'mine/feature-a', then `git push` will work, but\r\n`git rebase` won't.\r\n\r\nWith this option, `git rebase` uses the upstream branch, and `git push` uses\r\nthe publish branch.\r\n\r\nSetting the upstream tracking branch is easy:\r\n\r\n    git push --set-publish mine feature-a\r\n\r\nOr:\r\n\r\n    git branch --set-publish mine/feature-a\r\n\r\nAnd `git branch -v` will show it as well:\r\n\r\n```\r\n  fc/branch/fast      177dcad [master, gh/fc/branch/fast] branch: ...\r\n  fc/stage            abb6ad5 [master, gh/fc/stage] completion: ..\r\n  fc/transport/improv eb4d3c7 [master, gh/fc/transport/improv] ...\r\n```\r\n\r\n### Official staging area\r\n\r\nEverybody already uses the term \"staging area\" already, and Git developers also\r\nagreed it the best term to what is officially referred to as \"the index\". So\r\ngit-fc has new options for all commands that modify the staging area (e.g. `git\r\ngrep --staged`, `git rm --staged`), and also adds a new `git stage` command\r\nthat makes it easier to work with the staging area.\r\n\r\n```\r\n'git stage' [options] [--] [<paths>...]\r\n'git stage add' [options] [--] [<paths>...]\r\n'git stage reset' [-q|--patch] [--] [<paths>...]\r\n'git stage diff' [options] [<commit>] [--] [<paths>...]\r\n'git stage rm' [options] [--] [<paths>...]\r\n'git stage apply' [options] [--] [<paths>...]\r\n'git stage edit'\r\n```\r\n\r\nWithout any command, `git stage` adds files to the stage, same as `git add`, same as in Git mainline.\r\n\r\n### Nice 'branch -v'\r\n\r\nCurrently `git branch -v` will show you the tracking status (ahead/behind), but\r\nwouldn't show you which from which branch, and it takes considerable amount of\r\ntime (compared to most Git commands).\r\n\r\nThis is fixed so the branch is showed instead, which is more useful and faster.\r\nIf you want the tracking status, you can use `git branch -vv` which shows\r\neverything, as with Git mainline.\r\n\r\n```\r\n  fc/branch/fast      177dcad [master] branch: ...\r\n  fc/stage            abb6ad5 [master] completion: ...\r\n  fc/transport/improv eb4d3c7 [master] transport-helper: ...\r\n```\r\n\r\n### Default aliases\r\n\r\nMany (if not all) version control system tools have shortcuts for their most\r\ncommon operations; `hg ci`, `svn co`, `cvs st`, but not Git... git-fc does:\r\n\r\n    co = checkout\r\n    ci = commit\r\n    rb = rebase\r\n    st = status\r\n    br = branch\r\n    pi = cherry-pick\r\n    mt = mergetool\r\n\r\nIf you have already these aliases, or mapped to something else, your aliases\r\nwould take precedence over the default ones, so you won't have any problems.\r\n\r\n### New core.mode configuration\r\n\r\nThe behavior of Git v2.0 is already being defined, but there's no way to test\r\nit, if you want to test it, along with all future behaviors, you can enable it\r\non git-fc by setting the configuration `core.mode = next`.\r\n\r\nIn addition to the \"next\" (v2.0) mode, there's the \"progress\" mode. This mode\r\nenables \"next\" plus other configurations that are saner.\r\n\r\nIt is recommended that you setup this mode for git-fc:\r\n\r\n    git config --global core.mode progress\r\n\r\n### New fetch.default configuration\r\n\r\nWhen you have configured the upstream tracking branch for all your branches,\r\nyou will probably have tracking branches that point to a local branch, for\r\nexample 'feature-a' pointing to 'master', in which case you would get something\r\nlike:\r\n\r\n````\r\n% git fetch\r\nFrom .\r\n * branch            master     -> FETCH_HEAD\r\n````\r\n\r\nWhich makes absolutely no sense, since the '.' repository is not even\r\ndocumented, and FETCH_HEAD is a marginally known concept. In this case `git\r\nfetch` is basically doing nothing from the user's point of view.\r\n\r\nSo the user can configure `fetch.default = simple` to get a simple sensible\r\ndefault; `git fetch` will always use 'origin' by default.\r\n\r\nIf you use the \"progress\" mode, this option is also enabled.\r\n\r\n### Support for Ruby\r\n\r\nThere is partial optional support for Ruby. Git already has tooling so any\r\nlanguage can use it's plumbing and achieve plenty of tasks:\r\n\r\n```ruby\r\nIO.popen(%w[git for-each-ref]) do |io|\r\n  io.each do |line|\r\n    sha1, kind, name = line.split()\r\n    # stuff\r\n  end\r\nend\r\n```\r\n\r\nHowever, this a) requires a process fork, and b) requires I/O communication to\r\nget the desired data. While this is not a big deal on many systems, it is in\r\nWindows systems where forks are slow, and many Git core programs don't work as\r\nwell as they do in Linux.\r\n\r\nGit has a goal to replace all the core scripts with native C versions, but it's\r\na goal only in name that is not actually pursued. In addition, that still\r\nleaves out any third party tools since Git doesn't provide a shared libgit\r\nlibrary, which is why an independent libgit2 was needed in the first place.\r\n\r\nRuby bindings solve these problems:\r\n\r\n```ruby\r\nfor_each_ref() do |name, sha1, flags|\r\n  # stuff\r\nend\r\n```\r\n\r\nThe command `git ruby` can use this script by providing the bindings for many\r\nGit's internal C functions (though not all), which makes it easier to write\r\nRuby programs that take full advantage of Git without any need of forks, or I/O\r\ncommunication.\r\n\r\n## Contributions\r\n\r\nAll these patches were written by me, Felipe Contreras, but contributions from\r\nother people are welcome, as long as they follow these guidelines:\r\n\r\n1. Follows Git coding guidelines and is technically correct according to Git\r\n   standards\r\n2. Doesn't break backwards compatibility\r\n3. It doesn't conflict with other Git features so it can be rebased on newer\r\n   versions of Git without much maintenance burden\r\n\r\nPatches should be sent using `git send-email` to the mailing list git-fc@googlegroups.com.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}