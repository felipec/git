<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="git-fc : Fork of Git, same baseline, more features" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>git-fc</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/felipec/git">View on GitHub</a>

          <h1 id="project_title">git-fc</h1>
          <h2 id="project_tagline">Fork of Git, same baseline, more features</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/felipec/git/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/felipec/git/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="git-fc" class="anchor" href="#git-fc"><span class="octicon octicon-link"></span></a>git-fc</h1>

<p>git-fc is a friendly fork of Git, which means it's a fork that won't deviate
from the mainline; it is more like a branch in Git terms. This branch will move
forward close to Git's mainline, and it could be merged at any point in time,
if the maintainer wished to do so.</p>

<p>git-fc doesn't include experimental code, or half-assed features, so you can
expect the same level of stability as Git's mainline. Also, it doesn't remove
any feature, or do any backwards incompatible changes, so you can replace git
with git-fc and you wouldn't notice the difference. The difference comes in the
extra features, that is all.</p>

<h2>
<a name="maintenance" class="anchor" href="#maintenance"><span class="octicon octicon-link"></span></a>Maintenance</h2>

<p>Each release of Git is merged directly into git-fc, so if there's a new feature
in Git, git-fc will get it as well.</p>

<p>Every extra feature is maintained individually in a separate branch, so if you
are interested in a specific feature and don't trust the rest of git-fc, you
can use that branch instead. For example the publish tracking branch feature is
maintained in the 'fc/publish' branch which sits on top of git.git's v1.9.2.
You can grab the specific branch and do whatever you want with it.</p>

<h2>
<a name="extra-features" class="anchor" href="#extra-features"><span class="octicon octicon-link"></span></a>Extra features</h2>

<h3>
<a name="streamlined-remote-helpers" class="anchor" href="#streamlined-remote-helpers"><span class="octicon octicon-link"></span></a>Streamlined remote helpers</h3>

<p><code>git-remote-hg</code> and <code>git-remote-bzr</code> are remote helpers that allow two-way
communication between Git and Mercurial/Bazaar. They have been proven to be
very reliable and solid, and used by many people. In order to use them in Git
mainline you might need a bit of tinkering.</p>

<p>With git-fc they are installed by default, and in the right way. Plus there are
fixes in the remote helper infraestructure so they always work better than in
Git mainline.</p>

<h3>
<a name="new-git-update-tool" class="anchor" href="#new-git-update-tool"><span class="octicon octicon-link"></span></a>New 'git update' tool</h3>

<p>Everybody has agreed the <code>git pull</code> command is broken for most use-cases, which
is why most seasoned Git users avoid it, and it is recommended for new users to
avoid it.</p>

<p>A new tool is necessary for the most common use case, which is fetch all the
updates and update the current branch if possible.</p>

<p>The new <code>git update</code> will fast-forward to the latest commit in the remote
branch if there's no divergence (you haven't made extra commits). But if you
have made extra commits you will be told to either merge or rebase, or run <code>git
update --merge</code> or <code>git update --rebase</code>.</p>

<p>This ensures that new users won't be making merges by mistake.</p>

<p>Additionally, when doing a merge the order of the parents will be reversed, so
it would appear as if you are merging your local branch to the remote one, and
not the other way around like <code>git pull</code> does. Everybody has agreed this is a
problem with <code>git pull</code>.</p>

<h3>
<a name="publish-tracking-branch" class="anchor" href="#publish-tracking-branch"><span class="octicon octicon-link"></span></a>Publish tracking branch</h3>

<p>Git mainline doesn't have the greatest support for triangular workflows, a good
solution for that is to introduce a second "upstream" tracking branch which is
for the reverse; the branch you normally push to.</p>

<p>Say you clone a repository (libgit2) in GitHub, then create a branch
(feature-a) and push it to your personal repository, you would want to track
two branches (origin/master), and (mine/feature-a), but Git mainline only
provides support for a single upstream tracking branch.</p>

<p>If you setup your upstream tracking branch to 'origin/master', then you can
just do <code>git rebase</code> without arguments and git will pick the right branch
(origin/master) to rebase to. However, <code>git push</code> by default will also try to
push to 'origin/master', which is not what you want. Plus <code>git branch -v</code> will
show how ahead/behind your branch is compared to origin/master, not
mine/feature-a.</p>

<p>If you set up your upstream to 'mine/feature-a', then <code>git push</code> will work, but
<code>git rebase</code> won't.</p>

<p>With this option, <code>git rebase</code> uses the upstream branch, and <code>git push</code> uses
the publish branch.</p>

<p>Setting the upstream tracking branch is easy:</p>

<pre><code>git push --set-publish mine feature-a
</code></pre>

<p>Or:</p>

<pre><code>git branch --set-publish mine/feature-a
</code></pre>

<p>And <code>git branch -v</code> will show it as well:</p>

<pre><code>  fc/branch/fast      177dcad [master, gh/fc/branch/fast] branch: ...
  fc/stage            abb6ad5 [master, gh/fc/stage] completion: ..
  fc/transport/improv eb4d3c7 [master, gh/fc/transport/improv] ...
</code></pre>

<h3>
<a name="official-staging-area" class="anchor" href="#official-staging-area"><span class="octicon octicon-link"></span></a>Official staging area</h3>

<p>Everybody already uses the term "staging area" already, and Git developers also
agreed it the best term to what is officially referred to as "the index". So
git-fc has new options for all commands that modify the staging area (e.g. <code>git
grep --staged</code>, <code>git rm --staged</code>), and also adds a new <code>git stage</code> command
that makes it easier to work with the staging area.</p>

<pre><code>'git stage' [options] [--] [&lt;paths&gt;...]
'git stage add' [options] [--] [&lt;paths&gt;...]
'git stage reset' [-q|--patch] [--] [&lt;paths&gt;...]
'git stage diff' [options] [&lt;commit&gt;] [--] [&lt;paths&gt;...]
'git stage rm' [options] [--] [&lt;paths&gt;...]
'git stage apply' [options] [--] [&lt;paths&gt;...]
'git stage edit'
</code></pre>

<p>Without any command, <code>git stage</code> adds files to the stage, same as <code>git add</code>, same as in Git mainline.</p>

<h3>
<a name="nice-branch--v" class="anchor" href="#nice-branch--v"><span class="octicon octicon-link"></span></a>Nice 'branch -v'</h3>

<p>Currently <code>git branch -v</code> will show you the tracking status (ahead/behind), but
wouldn't show you which from which branch, and it takes considerable amount of
time (compared to most Git commands).</p>

<p>This is fixed so the branch is showed instead, which is more useful and faster.
If you want the tracking status, you can use <code>git branch -vv</code> which shows
everything, as with Git mainline.</p>

<pre><code>  fc/branch/fast      177dcad [master] branch: ...
  fc/stage            abb6ad5 [master] completion: ...
  fc/transport/improv eb4d3c7 [master] transport-helper: ...
</code></pre>

<h3>
<a name="default-aliases" class="anchor" href="#default-aliases"><span class="octicon octicon-link"></span></a>Default aliases</h3>

<p>Many (if not all) version control system tools have shortcuts for their most
common operations; <code>hg ci</code>, <code>svn co</code>, <code>cvs st</code>, but not Git... git-fc does:</p>

<pre><code>co = checkout
ci = commit
rb = rebase
st = status
br = branch
pi = cherry-pick
mt = mergetool
</code></pre>

<p>If you have already these aliases, or mapped to something else, your aliases
would take precedence over the default ones, so you won't have any problems.</p>

<h3>
<a name="new-coremode-configuration" class="anchor" href="#new-coremode-configuration"><span class="octicon octicon-link"></span></a>New core.mode configuration</h3>

<p>The behavior of Git v2.0 is already being defined, but there's no way to test
it, if you want to test it, along with all future behaviors, you can enable it
on git-fc by setting the configuration <code>core.mode = next</code>.</p>

<p>In addition to the "next" (v2.0) mode, there's the "progress" mode. This mode
enables "next" plus other configurations that are saner.</p>

<p>It is recommended that you setup this mode for git-fc:</p>

<pre><code>git config --global core.mode progress
</code></pre>

<h3>
<a name="new-fetchdefault-configuration" class="anchor" href="#new-fetchdefault-configuration"><span class="octicon octicon-link"></span></a>New fetch.default configuration</h3>

<p>When you have configured the upstream tracking branch for all your branches,
you will probably have tracking branches that point to a local branch, for
example 'feature-a' pointing to 'master', in which case you would get something
like:</p>

<pre><code>% git fetch
From .
 * branch            master     -&gt; FETCH_HEAD
</code></pre>

<p>Which makes absolutely no sense, since the '.' repository is not even
documented, and FETCH_HEAD is a marginally known concept. In this case <code>git
fetch</code> is basically doing nothing from the user's point of view.</p>

<p>So the user can configure <code>fetch.default = simple</code> to get a simple sensible
default; <code>git fetch</code> will always use 'origin' by default.</p>

<p>If you use the "progress" mode, this option is also enabled.</p>

<h3>
<a name="support-for-ruby" class="anchor" href="#support-for-ruby"><span class="octicon octicon-link"></span></a>Support for Ruby</h3>

<p>There is partial optional support for Ruby. Git already has tooling so any
language can use it's plumbing and achieve plenty of tasks:</p>

<div class="highlight highlight-ruby"><pre><span class="no">IO</span><span class="o">.</span><span class="n">popen</span><span class="p">(</span><span class="sx">%w[git for-each-ref]</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">io</span><span class="o">|</span>
  <span class="n">io</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">line</span><span class="o">|</span>
    <span class="n">sha1</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="nb">name</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="c1"># stuff</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>However, this a) requires a process fork, and b) requires I/O communication to
get the desired data. While this is not a big deal on many systems, it is in
Windows systems where forks are slow, and many Git core programs don't work as
well as they do in Linux.</p>

<p>Git has a goal to replace all the core scripts with native C versions, but it's
a goal only in name that is not actually pursued. In addition, that still
leaves out any third party tools since Git doesn't provide a shared libgit
library, which is why an independent libgit2 was needed in the first place.</p>

<p>Ruby bindings solve these problems:</p>

<div class="highlight highlight-ruby"><pre><span class="n">for_each_ref</span><span class="p">()</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="p">,</span> <span class="n">sha1</span><span class="p">,</span> <span class="n">flags</span><span class="o">|</span>
  <span class="c1"># stuff</span>
<span class="k">end</span>
</pre></div>

<p>The command <code>git ruby</code> can use this script by providing the bindings for many
Git's internal C functions (though not all), which makes it easier to write
Ruby programs that take full advantage of Git without any need of forks, or I/O
communication.</p>

<h2>
<a name="contributions" class="anchor" href="#contributions"><span class="octicon octicon-link"></span></a>Contributions</h2>

<p>All these patches were written by me, Felipe Contreras, but contributions from
other people are welcome, as long as they follow these guidelines:</p>

<ol>
<li>Follows Git coding guidelines and is technically correct according to Git
standards</li>
<li>Doesn't break backwards compatibility</li>
<li>It doesn't conflict with other Git features so it can be rebased on newer
versions of Git without much maintenance burden</li>
</ol><p>Patches should be sent using <code>git send-email</code> to the mailing list <a href="mailto:git-fc@googlegroups.com">git-fc@googlegroups.com</a>.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">git-fc maintained by <a href="https://github.com/felipec">felipec</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
